import { MCPTool } from './index.js';
import { z } from 'zod';
import { dockerHubClient } from '../clients/dockerhub.js';
import { ErrorHandler } from '../utils/error-handler.js';
import axios from 'axios';

/**
 * Enhanced Vulnerability Analysis Tool with CVE cross-referencing and filtering
 */

export const EnhancedVulnerabilityArgsSchema = z.object({
  repository: z.string().describe('Repository name (e.g., "library/nginx" or "user/repo")'),
  tag: z.string().default('latest').describe('Image tag'),
  severity_filter: z.array(z.enum(['critical', 'high', 'medium', 'low', 'unknown'])).optional().describe('Filter by vulnerability severity levels'),
  include_cve_details: z.boolean().default(true).describe('Include detailed CVE information from NVD database'),
  security_policy: z.object({
    max_age_days: z.number().optional().describe('Maximum allowed image age in days'),
    min_severity_threshold: z.enum(['critical', 'high', 'medium', 'low']).optional().describe('Minimum severity level to report'),
    blocked_packages: z.array(z.string()).optional().describe('List of blocked package names'),
    required_labels: z.array(z.string()).optional().describe('Required security labels'),
  }).optional().describe('Security policy validation rules'),
  export_format: z.enum(['json', 'csv', 'sarif']).default('json').describe('Export format for security report'),
});

export type EnhancedVulnerabilityArgs = z.infer<typeof EnhancedVulnerabilityArgsSchema>;

export const enhancedVulnerabilityTool: MCPTool<EnhancedVulnerabilityArgs> = {
  name: 'docker_enhanced_vulnerability_analysis',
  description: 'Comprehensive vulnerability analysis with CVE cross-referencing, severity filtering, security policy validation, and multiple export formats.',
  inputSchema: EnhancedVulnerabilityArgsSchema,
  
  async execute(args: EnhancedVulnerabilityArgs) {
    const { repository, tag, severity_filter, include_cve_details, security_policy, export_format } = args;

    console.log(`Performing enhanced vulnerability analysis for ${repository}:${tag}...`);

    try {
      // Get base vulnerability data
      const [vulnerabilityReport, imageDetails, manifest] = await Promise.all([
        dockerHubClient.getVulnerabilities(repository, tag),
        dockerHubClient.getRepositoryDetails(repository),
        dockerHubClient.getManifest(repository, tag).catch(() => null), // Optional
      ]);

      if (!vulnerabilityReport) {
        return {
          repository,
          tag,
          scan_available: false,
          message: 'Vulnerability scan not available for this image',
          recommendations: [
            'Vulnerability scanning may not be available for this image type',
            'Consider using official images which typically have scan results',
            'Check if the image is from a verified publisher',
          ],
        };
      }

      // Apply severity filtering
      const filteredVulnerabilities = severity_filter 
        ? vulnerabilityReport.vulnerabilities.filter(v => severity_filter.includes(v.severity))
        : vulnerabilityReport.vulnerabilities;

      // Enhance vulnerabilities with CVE details if requested
      const enhancedVulnerabilities = include_cve_details 
        ? await enhanceWithCVEDetails(filteredVulnerabilities)
        : filteredVulnerabilities.map(v => ({ ...v, cve_details: null }));

      // Group and categorize vulnerabilities
      const groupedVulnerabilities = groupVulnerabilities(enhancedVulnerabilities);

      // Perform security policy validation
      const policyViolations = security_policy 
        ? await validateSecurityPolicy(repository, tag, imageDetails, vulnerabilityReport, manifest, security_policy)
        : [];

      // Calculate risk score
      const riskScore = calculateRiskScore(enhancedVulnerabilities, imageDetails);

      // Generate comprehensive analysis
      const analysis = {
        repository,
        tag,
        scan_date: new Date().toISOString(),
        summary: {
          total_vulnerabilities: enhancedVulnerabilities.length,
          by_severity: groupedVulnerabilities.by_severity,
          risk_score: riskScore,
          compliance_status: policyViolations.length === 0 ? 'COMPLIANT' : 'NON_COMPLIANT',
        },
        vulnerabilities: {
          total: enhancedVulnerabilities.length,
          filtered: severity_filter ? `Filtered by: ${severity_filter.join(', ')}` : 'No filtering applied',
          by_severity: groupedVulnerabilities.by_severity,
          by_package: groupedVulnerabilities.by_package,
          by_cve_type: groupedVulnerabilities.by_cve_type,
          details: enhancedVulnerabilities.slice(0, 50), // Limit for performance
        },
        security_analysis: {
          risk_factors: generateRiskFactors(enhancedVulnerabilities, imageDetails),
          recommendations: generateSecurityRecommendations(enhancedVulnerabilities, imageDetails, policyViolations),
          compliance_check: {
            policy_violations: policyViolations,
            passed_checks: generatePassedChecks(security_policy, policyViolations),
          },
        },
        cve_intelligence: include_cve_details ? {
          total_cves: enhancedVulnerabilities.filter(v => v.cve_details).length,
          recent_cves: enhancedVulnerabilities.filter(v => 
            v.cve_details && isRecentCVE(v.cve_details.published_date)
          ).length,
          exploitable_cves: enhancedVulnerabilities.filter(v => 
            v.cve_details && v.cve_details.exploitability_score > 7
          ).length,
        } : null,
        image_metadata: {
          last_updated: imageDetails.last_updated,
          image_age_days: Math.floor((Date.now() - new Date(imageDetails.last_updated).getTime()) / (1000 * 60 * 60 * 24)),
          is_official: imageDetails.namespace === 'library',
          is_automated: imageDetails.is_automated,
          pull_count: imageDetails.pull_count,
          star_count: imageDetails.star_count,
        },
      };

      // Apply export formatting
      return await formatSecurityReport(analysis, export_format);

    } catch (error) {
      throw ErrorHandler.handleError(error);
    }
  },
};

/**
 * Enhance vulnerabilities with CVE details from NVD database
 */
async function enhanceWithCVEDetails(vulnerabilities: any[]): Promise<any[]> {
  console.log(`Enhancing ${vulnerabilities.length} vulnerabilities with CVE details...`);
  
  const enhanced = await Promise.all(
    vulnerabilities.map(async (vulnerability) => {
      try {
        // Extract CVE ID from vulnerability
        const cveId = extractCVEId(vulnerability);
        if (!cveId) {
          return { ...vulnerability, cve_details: null };
        }

        // Fetch CVE details from NVD API (with rate limiting)
        const cveDetails = await fetchCVEDetails(cveId);
        
        return {
          ...vulnerability,
          cve_details: cveDetails,
        };
      } catch (error) {
        console.warn(`Failed to fetch CVE details for ${vulnerability.id}:`, error);
        return { ...vulnerability, cve_details: null };
      }
    })
  );

  return enhanced;
}

/**
 * Extract CVE ID from vulnerability data
 */
function extractCVEId(vulnerability: any): string | null {
  // Try multiple fields where CVE ID might be stored
  const fields = [vulnerability.id, vulnerability.title, vulnerability.description];
  
  for (const field of fields) {
    if (typeof field === 'string') {
      const match = field.match(/CVE-\d{4}-\d{4,}/);
      if (match) {
        return match[0];
      }
    }
  }
  
  return null;
}

/**
 * Fetch CVE details from NVD API
 */
async function fetchCVEDetails(cveId: string): Promise<any> {
  try {
    // Note: In production, you should use proper API keys and rate limiting
    const response = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0`, {
      params: {
        cveId: cveId,
      },
      timeout: 5000,
    });

    if (response.data?.vulnerabilities?.[0]) {
      const cveData = response.data.vulnerabilities[0].cve;
      
      return {
        id: cveId,
        published_date: cveData.published,
        last_modified: cveData.lastModified,
        description: cveData.descriptions?.[0]?.value || 'No description available',
        cvss_v3_score: cveData.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || null,
        cvss_v3_vector: cveData.metrics?.cvssMetricV31?.[0]?.cvssData?.vectorString || null,
        exploitability_score: cveData.metrics?.cvssMetricV31?.[0]?.exploitabilityScore || 0,
        impact_score: cveData.metrics?.cvssMetricV31?.[0]?.impactScore || 0,
        references: cveData.references?.slice(0, 5).map((ref: any) => ({
          url: ref.url,
          source: ref.source,
          tags: ref.tags,
        })) || [],
        configurations: cveData.configurations?.nodes?.length || 0,
      };
    }
    
    return null;
  } catch (error) {
    console.warn(`Failed to fetch CVE details for ${cveId}:`, error);
    return null;
  }
}

/**
 * Group vulnerabilities by various criteria
 */
function groupVulnerabilities(vulnerabilities: any[]): any {
  const by_severity = vulnerabilities.reduce((acc, vuln) => {
    acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
    return acc;
  }, {});

  const by_package = vulnerabilities.reduce((acc, vuln) => {
    const pkg = vuln.package_name || 'unknown';
    if (!acc[pkg]) {
      acc[pkg] = { count: 0, severities: new Set() };
    }
    acc[pkg].count++;
    acc[pkg].severities.add(vuln.severity);
    return acc;
  }, {});

  // Convert sets to arrays for JSON serialization
  Object.keys(by_package).forEach(pkg => {
    by_package[pkg].severities = Array.from(by_package[pkg].severities);
  });

  const by_cve_type = vulnerabilities.reduce((acc, vuln) => {
    if (vuln.cve_details) {
      if (vuln.cve_details.cvss_v3_score >= 9.0) {
        acc.critical_cves = (acc.critical_cves || 0) + 1;
      } else if (vuln.cve_details.exploitability_score > 7) {
        acc.easily_exploitable = (acc.easily_exploitable || 0) + 1;
      }
      
      if (isRecentCVE(vuln.cve_details.published_date)) {
        acc.recent_cves = (acc.recent_cves || 0) + 1;
      }
    }
    return acc;
  }, {});

  return {
    by_severity,
    by_package,
    by_cve_type,
  };
}

/**
 * Validate security policy compliance
 */
async function validateSecurityPolicy(
  repository: string,
  tag: string,
  imageDetails: any,
  vulnerabilityReport: any,
  manifest: any,
  policy: any
): Promise<any[]> {
  const violations = [];

  // Check image age policy
  if (policy.max_age_days) {
    const imageAge = Math.floor((Date.now() - new Date(imageDetails.last_updated).getTime()) / (1000 * 60 * 60 * 24));
    if (imageAge > policy.max_age_days) {
      violations.push({
        type: 'IMAGE_AGE_VIOLATION',
        severity: 'medium',
        message: `Image is ${imageAge} days old, exceeding maximum allowed age of ${policy.max_age_days} days`,
        current_value: imageAge,
        policy_limit: policy.max_age_days,
      });
    }
  }

  // Check severity threshold policy
  if (policy.min_severity_threshold) {
    const severityOrder = ['low', 'medium', 'high', 'critical'];
    const thresholdIndex = severityOrder.indexOf(policy.min_severity_threshold);
    
    const violatingSeverities = vulnerabilityReport.vulnerabilities.filter((v: any) => {
      const vulnIndex = severityOrder.indexOf(v.severity);
      return vulnIndex >= thresholdIndex;
    });

    if (violatingSeverities.length > 0) {
      violations.push({
        type: 'SEVERITY_THRESHOLD_VIOLATION',
        severity: 'high',
        message: `Found ${violatingSeverities.length} vulnerabilities at or above ${policy.min_severity_threshold} severity`,
        violating_vulnerabilities: violatingSeverities.length,
        threshold: policy.min_severity_threshold,
      });
    }
  }

  // Check blocked packages
  if (policy.blocked_packages && policy.blocked_packages.length > 0) {
    const blockedFound = vulnerabilityReport.vulnerabilities.filter((v: any) => 
      policy.blocked_packages.includes(v.package_name)
    );

    if (blockedFound.length > 0) {
      violations.push({
        type: 'BLOCKED_PACKAGE_VIOLATION',
        severity: 'high',
        message: `Found vulnerabilities in blocked packages: ${blockedFound.map((v: any) => v.package_name).join(', ')}`,
        blocked_packages_found: blockedFound.map((v: any) => v.package_name),
        policy_blocked_packages: policy.blocked_packages,
      });
    }
  }

  // Check required labels (if manifest is available)
  if (policy.required_labels && policy.required_labels.length > 0 && manifest) {
    try {
      const imageConfig = await dockerHubClient.getImageConfig(repository, tag);
      const labels = imageConfig.config?.Labels || {};
      const missingLabels = policy.required_labels.filter((label: string) => !labels[label]);

      if (missingLabels.length > 0) {
        violations.push({
          type: 'MISSING_REQUIRED_LABELS',
          severity: 'low',
          message: `Missing required security labels: ${missingLabels.join(', ')}`,
          missing_labels: missingLabels,
          required_labels: policy.required_labels,
        });
      }
    } catch (error) {
      console.warn('Could not check required labels:', error);
    }
  }

  return violations;
}

/**
 * Calculate overall risk score
 */
function calculateRiskScore(vulnerabilities: any[], imageDetails: any): number {
  let score = 0;
  
  // Base score from vulnerability counts and severities
  vulnerabilities.forEach(vuln => {
    switch (vuln.severity) {
      case 'critical': score += 10; break;
      case 'high': score += 7; break;
      case 'medium': score += 4; break;
      case 'low': score += 1; break;
    }
  });

  // Adjust for image factors
  const imageAge = Math.floor((Date.now() - new Date(imageDetails.last_updated).getTime()) / (1000 * 60 * 60 * 24));
  if (imageAge > 180) score += 10; // Old images are riskier
  if (imageAge > 365) score += 20;

  if (!imageDetails.is_automated) score += 5; // Manual builds may be less consistent
  if (imageDetails.namespace !== 'library') score += 3; // Non-official images slightly riskier

  // CVE-specific risk factors
  vulnerabilities.forEach(vuln => {
    if (vuln.cve_details) {
      if (vuln.cve_details.exploitability_score > 8) score += 5;
      if (isRecentCVE(vuln.cve_details.published_date)) score += 3;
    }
  });

  // Normalize to 0-100 scale
  return Math.min(100, Math.max(0, score));
}

/**
 * Generate risk factors analysis
 */
function generateRiskFactors(vulnerabilities: any[], imageDetails: any): string[] {
  const factors = [];
  
  const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
  const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
  
  if (criticalCount > 0) {
    factors.push(`${criticalCount} critical vulnerabilities present`);
  }
  if (highCount > 5) {
    factors.push(`High number of high-severity vulnerabilities (${highCount})`);
  }

  const imageAge = Math.floor((Date.now() - new Date(imageDetails.last_updated).getTime()) / (1000 * 60 * 60 * 24));
  if (imageAge > 180) {
    factors.push(`Image is outdated (${imageAge} days old)`);
  }

  const recentCVEs = vulnerabilities.filter(v => 
    v.cve_details && isRecentCVE(v.cve_details.published_date)
  ).length;
  if (recentCVEs > 0) {
    factors.push(`Contains ${recentCVEs} recently disclosed vulnerabilities`);
  }

  const exploitableCVEs = vulnerabilities.filter(v => 
    v.cve_details && v.cve_details.exploitability_score > 7
  ).length;
  if (exploitableCVEs > 0) {
    factors.push(`Contains ${exploitableCVEs} easily exploitable vulnerabilities`);
  }

  if (factors.length === 0) {
    factors.push('No significant risk factors identified');
  }

  return factors;
}

/**
 * Generate security recommendations
 */
function generateSecurityRecommendations(vulnerabilities: any[], imageDetails: any, policyViolations: any[]): string[] {
  const recommendations = [];

  const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
  const highCount = vulnerabilities.filter(v => v.severity === 'high').length;

  if (criticalCount > 0) {
    recommendations.push(`URGENT: Address ${criticalCount} critical vulnerabilities immediately`);
  }
  if (highCount > 0) {
    recommendations.push(`Prioritize fixing ${highCount} high-severity vulnerabilities`);
  }

  const imageAge = Math.floor((Date.now() - new Date(imageDetails.last_updated).getTime()) / (1000 * 60 * 60 * 24));
  if (imageAge > 180) {
    recommendations.push('Consider updating to a newer image version');
  }

  if (policyViolations.length > 0) {
    recommendations.push(`Address ${policyViolations.length} security policy violations`);
  }

  // Package-specific recommendations
  const packageVulns = vulnerabilities.reduce((acc, vuln) => {
    const pkg = vuln.package_name;
    if (!acc[pkg]) acc[pkg] = [];
    acc[pkg].push(vuln);
    return acc;
  }, {});

  Object.entries(packageVulns).forEach(([pkg, vulns]: [string, any]) => {
    if (vulns.length > 3) {
      recommendations.push(`Consider replacing or updating package '${pkg}' (${vulns.length} vulnerabilities)`);
    }
  });

  if (recommendations.length === 0) {
    recommendations.push('No immediate security actions required');
  }

  return recommendations;
}

/**
 * Generate list of passed security checks
 */
function generatePassedChecks(policy: any, violations: any[]): string[] {
  if (!policy) return [];

  const passed = [];
  const violationTypes = violations.map(v => v.type);

  if (policy.max_age_days && !violationTypes.includes('IMAGE_AGE_VIOLATION')) {
    passed.push(`Image age within acceptable limits (${policy.max_age_days} days)`);
  }
  if (policy.min_severity_threshold && !violationTypes.includes('SEVERITY_THRESHOLD_VIOLATION')) {
    passed.push(`No vulnerabilities above ${policy.min_severity_threshold} severity threshold`);
  }
  if (policy.blocked_packages && !violationTypes.includes('BLOCKED_PACKAGE_VIOLATION')) {
    passed.push('No blocked packages detected');
  }
  if (policy.required_labels && !violationTypes.includes('MISSING_REQUIRED_LABELS')) {
    passed.push('All required security labels present');
  }

  return passed;
}

/**
 * Check if CVE is recent (within last 90 days)
 */
function isRecentCVE(publishedDate: string): boolean {
  if (!publishedDate) return false;
  const published = new Date(publishedDate);
  const ninetyDaysAgo = new Date();
  ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
  return published > ninetyDaysAgo;
}

/**
 * Format security report in different formats
 */
async function formatSecurityReport(analysis: any, format: string): Promise<any> {
  switch (format) {
    case 'csv':
      return {
        ...analysis,
        exported_data: formatAsCSV(analysis),
        export_info: {
          format: 'csv',
          description: 'Vulnerability data in CSV format for spreadsheet analysis',
        },
      };
    
    case 'sarif':
      return {
        ...analysis,
        exported_data: formatAsSARIF(analysis),
        export_info: {
          format: 'sarif',
          description: 'SARIF format for integration with security tools',
        },
      };
    
    case 'json':
    default:
      return analysis;
  }
}

/**
 * Format vulnerability data as CSV
 */
function formatAsCSV(analysis: any): string {
  const vulnerabilities = analysis.vulnerabilities.details;
  const csvData = vulnerabilities.map((vuln: any) => ({
    vulnerability_id: vuln.id,
    severity: vuln.severity,
    package_name: vuln.package_name,
    package_version: vuln.package_version,
    fix_version: vuln.fix_version || '',
    title: vuln.title,
    description: vuln.description.replace(/\n/g, ' ').substring(0, 200),
    cve_id: vuln.cve_details?.id || '',
    cvss_score: vuln.cve_details?.cvss_v3_score || '',
    exploitability_score: vuln.cve_details?.exploitability_score || '',
    published_date: vuln.cve_details?.published_date || '',
  }));

  const headers = Object.keys(csvData[0] || {}).join(',');
  const rows = csvData.map((row: any) => Object.values(row).map(val => `"${val}"`).join(','));
  
  return [headers, ...rows].join('\n');
}

/**
 * Format vulnerability data as SARIF
 */
function formatAsSARIF(analysis: any): any {
  const vulnerabilities = analysis.vulnerabilities.details;
  
  return {
    $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',
    version: '2.1.0',
    runs: [{
      tool: {
        driver: {
          name: 'Docker Hub MCP Vulnerability Scanner',
          version: '1.0.0',
          informationUri: 'https://github.com/your-repo/mcp-docker',
        },
      },
      results: vulnerabilities.map((vuln: any) => ({
        ruleId: vuln.id,
        message: {
          text: vuln.title,
        },
        level: mapSeverityToSARIF(vuln.severity),
        locations: [{
          physicalLocation: {
            artifactLocation: {
              uri: `docker://${analysis.repository}:${analysis.tag}`,
            },
            region: {
              snippet: {
                text: `Package: ${vuln.package_name}@${vuln.package_version}`,
              },
            },
          },
        }],
        properties: {
          package: vuln.package_name,
          version: vuln.package_version,
          fixVersion: vuln.fix_version,
          cveId: vuln.cve_details?.id,
          cvssScore: vuln.cve_details?.cvss_v3_score,
        },
      })),
    }],
  };
}

/**
 * Map vulnerability severity to SARIF level
 */
function mapSeverityToSARIF(severity: string): string {
  switch (severity) {
    case 'critical': return 'error';
    case 'high': return 'error';
    case 'medium': return 'warning';
    case 'low': return 'note';
    default: return 'note';
  }
}
